#pragma config(Sensor, S1,     LightSensor,    sensorLightActive)
#pragma config(Motor,  motorA,          InMotor,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          LeftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          RightMotor,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#define R 2.78
//#define L 11.0

#define R 2.1
#define L 9.9

//#define R 1.85
//#define L 10.5

#define PI 3.1415926536

typedef struct coord {
	float x;
	float y;
} point;

//Global variables - you will need to change some of these
float robot_X = 0.0, robot_Y = 0.0, robot_TH = 0.0;
int oldL = 0, oldR = 0, oldT = 0;
int velocityUpdateInterval = 10;
int PIDUpdateInterval = 15;
int inputB[3] = {0, 0, 0};
int inputC[3] = {0, 0, 0};

float max(float a, float b){
	if(a > b)
		return a;
	return b;
}

float min(float a, float b){
	if(a < b)
		return a;
	return b;
}

/*****************************************
 * Complete this function so that it
 * continuously updates the robot's position
 *****************************************/
task dead_reckoning()
{
	oldL = nMotorEncoder[LeftMotor];
	oldR = nMotorEncoder[RightMotor];
	oldT = nPgmTime;
	int loops = 0;
	while(1)
	{
		int curTime = nPgmTime;
		int leftEnc = nMotorEncoder[LeftMotor];
		int rightEnc = nMotorEncoder[RightMotor];
		float t = (curTime - oldT) / 1000.0;
		if(t == 0){
			continue;
		}
		loops++;
		float vl = (leftEnc - oldL) / t * PI / 180.0 * R;
		float vr = (rightEnc - oldR) / t * PI / 180.0 * R;

		//float v2 = min(vr, vl);
		float vmax = max(abs(vr), abs(vl));
		float r1;
		if(vr != vl){
			r1 = abs(vmax*L/(vr - vl));
		}
		else{
			r1 = L/2;
		}
		nxtDisplayTextLine(3,"in1: %d, %d", inputB[0],inputC[0]);
		nxtDisplayTextLine(4,"in2: %d, %d", inputB[1],inputC[1]);
		nxtDisplayTextLine(5,"in3: %d, %d", inputB[2],inputC[2]);

		float v = (vr + vl) / 2.0;

		if(v < 0){
			r1 = r1 * -.000455 + 1.0045;
		}
		else{
			r1 = r1 * -.002191 + .9885124;
		}
		float w = (vr - vl) / L * r1;

		float k00 = v*cos(robot_TH);
		float k01 = v*sin(robot_TH);
		float k02 = w;
		float k10 = v*cos(robot_TH + k02*.5*t);
		float k11 = v*sin(robot_TH + k02*.5*t);
		float k12 = w;
		float k20 = v*cos(robot_TH + k12*.5*t);
		float k21 = v*sin(robot_TH + k12*.5*t);
		float k22 = w;
		float k30 = v*cos(robot_TH + k22*t);
		float k31 = v*sin(robot_TH + k22*t);
		float k32 = w;

		robot_X += t/6.0 * (k00 + 2*(k10 + k20) + k30);
		robot_Y += t/6.0 * (k01 + 2*(k11 + k21) + k31);
		robot_TH -= t/6.0 * (k02 + 2*(k12 + k22) + k32);

		//Code that plots the robot's current position and also prints it out as text
		nxtSetPixel(50 + (int)(100.0 * robot_X), 32 + (int)(100.0 * robot_Y));
		nxtDisplayTextLine(0, "X: %f", robot_X);
		nxtDisplayTextLine(1, "Y: %f", robot_Y);
		nxtDisplayTextLine(2, "t: %f", 57.2958 * robot_TH);


		wait1Msec(velocityUpdateInterval);
		oldL = leftEnc;
		oldR = rightEnc;
		oldT = curTime;
	}
}

/*****************************************
 * Function that draws a grid on the LCD
 * for easier readout of whatever is plot
 *****************************************/
void draw_grid()
{
	for(int i = 0; i < 65; i++)
	{
		nxtSetPixel(50, i);
		int grid5 = (i - 32) % 5;
		int grid10 = (i - 32) % 10;
		if(!grid5 && grid10)
		{
			for(int j = -2; j < 3; j++)
			{
				nxtSetPixel(50 + j, i);
			}
		}
		else if(!grid10)
		{
			for(int j = -4; j < 5; j++)
			{
				nxtSetPixel(50 + j, i);
			}
		}
	}
	for(int i = 0; i < 101; i++)
	{
		nxtSetPixel(i, 32);
		int grid5 = (i - 100) % 5;
		int grid10 = (i - 100) % 10;
		if(!grid5 && grid10)
		{
			for(int j = -2; j < 3; j++)
			{
				nxtSetPixel(i, 32 + j);
			}
		}
		else if(!grid10)
		{
			for(int j = -4; j < 5; j++)
			{
				nxtSetPixel(i, 32 + j);
			}
		}
	}
}

/*****************************************
 * Function that fills in the inputB and
 * inputC arrays with values inputted
 * through motorA
 *****************************************/
void getInput()
{
	int i = 0;
	nMotorEncoder[motorA] = 0;
	nNxtButtonTask = 0;
	while(i < 3)
	{
		while(nNxtButtonPressed != kEnterButton)
		{
			inputB[i] = (int)(nMotorEncoder[motorA] / 5.0);
			if(inputB[i] > 100) {inputB[i] = 100; nMotorEncoder[motorA] = 100;}
			else if(inputB[i] < -100) {inputB[i] = -100; nMotorEncoder[motorA] = -100;}
			nxtDisplayTextLine(2 * i, "B : %d", inputB[i]);
			wait10Msec(1);
		}
		wait10Msec(30);
		while(nNxtButtonPressed != kEnterButton)
		{
			inputC[i] = (int)(nMotorEncoder[motorA] / 5.0);
			if(inputC[i] > 100) {inputC[i] = 100; nMotorEncoder[motorA] = 100;}
			else if(inputC[i] < -100) {inputC[i] = -100; nMotorEncoder[motorA] = -100;}
			nxtDisplayTextLine(2 * i + 1, "C : %d", inputC[i]);
			wait10Msec(1);
		}
		i++;
		nMotorEncoder[motorA] = 0;
		wait10Msec(30);
	}
	for(int j = 0; j < 8; j++)
		nxtDisplayClearTextLine(j);
}

/*****************************************
 * Trajectories - these functions define
 * the sample trajectories
 *****************************************/

void traj1 (float t, point p)
{
	p->x = 0.5 * cos(t/10) * sin(t/10);
	p->y = 0.2 * sin(t/10) * sin(t/5);
}

void traj2 (float t, point p)
{
	p->x = 0.2 * sin(3*t/5);
	p->y = 0.2 * cos(2*(t/5 + PI/4));
}

void traj3 (float t, point p)
{
	p->x = 0.2 * cos(t/10) * cos(t/5);
	p->y = 0.2 * cos(3*t/10) * sin(t/10);
}

void traj4 (float t, point p)
{
	p->x = 0.2 * (0.5 * cos(3*t/10) - 0.75 * cos(t/5));
	p->y = 0.2 * (-0.75 * sin(t/5) - 0.5 * sin(3*t/10));
}

void traj5 (float t, point p)
{
	float c = cos(t/5);
	p->x = 0.1 * (-2*c*c - sin(t/10) + 1) * sin(t/5);
	p->y = 0.1 * (-2*c*c*c - sint(t/10) + 1);
}

void traj6 (float t, point p)
{
	float c = cos(t/12);
	float s = sin(t/4);
	p->x = 0.1 * (2*c*c*c + 1)*s;
	p->y = 0.1 * c * (1 - 2*s*s*s*s);
}

void traj7 (float t, point p)
{
	p->x = 0.04 * (5*cos(9*t/20) - 4*cos(t/4));
	p->y = 0.04 * (-4*sin(t/4) - 5*sin(9*t/20));
}

/*****************************************
 * Main function - it is not necessary to
 * modify this
 *****************************************/
task main()
{
  /* Reset encoders and turn on PID control */
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
	nPidUpdateInterval = PIDUpdateInterval;

	getInput();

	draw_grid();
	time1[T1] = 0;
	startTask(dead_reckoning);
	for(int i = 0; i < 3; i++)
	{
		motor[motorB] = inputB[i];
		motor[motorC] = inputC[i];

		wait10Msec(100 * 5);
		motor[motorB] = 0;
		motor[motorC] = 0;
		wait1Msec(200);
  }
  motor[motorB] = 0;
	motor[motorC] = 0;
	nNxtButtonTask  = 0;
	while(nNxtButtonPressed != kExitButton) {}
}
